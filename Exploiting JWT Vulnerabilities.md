# Penetration Testing: Exploiting JWT Vulnerabilities

## Introduction

JSON Web Tokens (JWTs) are widely used in modern web applications for authentication, session management, and access control. JWTs offer flexibility in how they are implemented, but this flexibility can also lead to serious security vulnerabilities if not handled properly. As the data is stored client-side, vulnerabilities related to JWTs can result in authentication bypass, privilege escalation, and sensitive data exposure.

The key to understanding JWT attacks is recognizing that JWTs, although signed, do not necessarily guarantee the integrity of their contents unless implemented securely. These vulnerabilities arise from flaws such as improper signature verification, weak secret keys, and inadequate token validation practices.

### Why JWT Security Matters
1. **Authentication Bypass**: JWT vulnerabilities may allow attackers to impersonate other users or escalate privileges.
2. **Session Hijacking**: Misuse of JWTs in session management can allow attackers to take over legitimate user sessions.
3. **Data Tampering**: Without proper signature verification, attackers can tamper with the payload or header claims.
4. **Exposure of Sensitive Information**: Improper token storage or handling can lead to leakage of user or application data.

Ensuring the secure handling of JWTs is critical to maintaining the security of web applications and preventing the compromise of both user data and application integrity.

---

## JWT Vulnerability Pentesting Checklist

### 1. **Unverified Signature**
   - **Vulnerability**: JWT signature not being properly verified.
   - **How to Find**: Check if the application decodes the token without verifying the signature. Use a modified token (with an invalid or no signature) and observe if the server still accepts it.
   - **Example**:
     ```json
     {
       "alg": "none"
     }
     ```
     Send this token without a valid signature and see if access is granted.

### 2. **None Algorithm Bypass**
   - **Vulnerability**: Allowing the use of `alg: none` (no signature).
   - **How to Find**: Modify the JWT header to use the `none` algorithm and remove the signature section. Check if the application still accepts the token.
   - **Example**:
     Header: 
     ```json
     {
       "alg": "none",
       "typ": "JWT"
     }
     ```
     Payload and empty signature: 
     ```
     eyJhbGciOiJub25lIn0.eyJpc3MiOiJleGFtcGxlIn0.
     ```

### 3. **Weak Secret Key (HS256)**
   - **Vulnerability**: Weak or easily brute-forceable secret key used in HMAC-signed tokens (HS256).
   - **How to Find**: Brute-force the JWT signature using tools like `hashcat` with common wordlists.
   - **Example**:
     ```bash
     hashcat -a 0 -m 16500 <jwt_token> <wordlist>
     ```
     If successful, you will retrieve the weak secret key.

### 4. **Algorithm Confusion**
   - **Vulnerability**: Misconfiguration allowing switching from asymmetric (e.g., RS256) to symmetric algorithms (e.g., HS256).
   - **How to Find**: Modify the JWT to switch from RS256 to HS256. Use the public key (intended for RS256) as the HMAC secret and sign the token.
   - **Example**:
     Modify the header from:
     ```json
     {
       "alg": "RS256"
     }
     ```
     To:
     ```json
     {
       "alg": "HS256"
     }
     ```
     Then use the server's public key as the secret for HMAC signing.

### 5. **Key Injection via `kid` Header**
   - **Vulnerability**: Key injection in the `kid` (Key ID) parameter to use a predictable file for signature verification.
   - **How to Find**: Test directory traversal or point the `kid` to `/dev/null` and sign with an empty string.
   - **Example**:
     ```json
     {
       "kid": "../../../../../dev/null",
       "alg": "HS256"
     }
     ```
     Then sign the JWT with an empty key and verify if it is accepted.

### 6. **JWK Header Injection**
   - **Vulnerability**: Injecting a public key via the `jwk` header parameter, tricking the server to use the attacker’s key.
   - **How to Find**: Add the `jwk` parameter in the JWT header containing a crafted key. Observe if the server uses the key for signature verification.
   - **Example**:
     ```json
     {
       "alg": "RS256",
       "jwk": {
         "kty": "RSA",
         "n": "<your-public-key-modulus>",
         "e": "AQAB"
       }
     }
     ```

### 7. **JWK Set URL (`jku`) Injection**
   - **Vulnerability**: Specifying an arbitrary JWK Set URL (`jku` header) that the server fetches and trusts.
   - **How to Find**: Set a custom `jku` header pointing to your controlled server hosting a malicious JWK Set.
   - **Example**:
     ```json
     {
       "alg": "RS256",
       "jku": "http://attacker.com/jwks.json"
     }
     ```

### 8. **Expired or Invalid Token Acceptance**
   - **Vulnerability**: Accepting expired or improperly formatted tokens.
   - **How to Find**: Modify the `exp` (expiration) claim in the payload to a past time or remove it entirely, then check if the server still grants access.
   - **Example**:
     ```json
     {
       "exp": 1600000000
     }
     ```
     The server should reject this token, but if not, it’s a vulnerability.

### 9. **Replay Attack (Reusing JWT)**
   - **Vulnerability**: Tokens being reused (no token revocation mechanism or anti-replay measures).
   - **How to Find**: Capture a valid JWT, then replay it after the user has logged out or after a session timeout.
   - **Example**: If a user logs out but the token is still valid on the server, the vulnerability exists.

---

## Conclusion

Securing JWTs is crucial as their misuse can lead to catastrophic security failures, such as unauthorized access, privilege escalation, and data tampering. By systematically testing for these vulnerabilities and following best practices for token handling, developers can significantly reduce the risk of JWT-based attacks in their applications.
